# PowerGAUGE

(Producing Green Applications Using Genetic Exploration)

PowerGAUGE is an approach to optimizing non-functional properties of programs. In particular, it explores the tradeoffs between different non-functional properties, optimizing both if possible, and offering a range of options when improving one can only be done at the expense of another. It accomplishes this using an evolutionary algorithm that repeatedly makes small changes to the program, following up on beneficial changes and setting aside less-beneficial ones. After a predetermined number of attempts, it reports the programs that displayed the best tradeoffs.

PowerGAUGE takes the following inputs:
1. An assembly language program to optimize,
2. A command to build an executable binary from the assembly code, and
3. A command to measure the non-functional properties.

## Building

NOTE: PowerGAUGE has been exclusively tested on Linux systems. Getting it to compile and run on other operating systems will almost certainly require significant additional effort.

1. Download the GenProg evolutionary programming tool.

   ```bash
   git clone https://github.com/squaresLab/genprog-code.git
   ```

2. Follow the instructions in their README file to build GenProg (you will need an OCaml compiler).

3. Download this repository.

   ```bash
   git clone https://github.com/dornja/powergauge.git
   ```

4. Compile the utilities in the `src` directory.

    ```bash
    cd powergauge/src ; make
    ```

## Usage

### Setup and Inputs
This section provides an overview of the inputs to PowerGAUGE as well as some considerations to keep in mind while you are configuring your own applications for optimization.

> The `benchmarks` directory contains example configuration files and associated resources for optimizing benchmarks in the PARSEC suite. We will use the `swaptions` benchmark from that suite as a running example.
>
> You can download the core PARSEC benchmark suite from http://parsec.cs.princeton.edu/download/3.0/parsec-3.0-core.tar.gz.
> We will not need the larger input sizes for this example. Once you've downloaded it, extract it and set the PARSECDIR environment variable to point to the newly extracted directory.

PowerGAUGE operates on assembly programs, which can be generated as output by many compiler collections. These programs need not consist of a single assembly file, but may be distributed across a number of files. For example, to the `-S` option to `gcc` causes it to generate assembly files instead of binary objects. In many cases, the assembly files for a program can be generated by replacing the `-c` option in the compile commands with `-S` and rebuilding.

> The `benchmarks/swaptions/get_sources.sh` script generates the assembly code for the `swaptions` benchmark. Simply run it by running,
>
> ```bash
> cd benchmarks/swaptions
> ./get_sources.sh $PARSECDIR
> ```
>
> This will create a new `src` directory and fill it with the assembly files.

The second input to PowerGAUGE is a command to build the assembly files into an executable program. This command will be given the name of a file in the directory containing the modified assembly files (due to a quirk of GenProg, the file may not actually exist, although the directory will) along with the suggested name of the binary to create.

> The `benchmarks/swaptions/compile.sh` script builds the swaptions benchmark from a directory containing assembly files. You can see it in action on the `src` directory we just created by running,
>
> ```bash
> ./compile.sh src/icdf.s exe
> ```

The third input is a command to test the binary created by the build command. It will be given the same binary name that was given to the build command and a filename to write the measured non-functional values to. This test command is typically the most complicated of the inputs to create. There are a number of considerations to keep in mind:

1. If any of your non-functional properties are dynamic, it must run the command with a representative workload so that the properties may be measured. However, since PowerGAUGE will generate tens or hundreds of thousands of binaries, the workload and evaluation of properties should be fast enough that PowerGAUGE can finish in a reasonable time.
2. The test command should also check that the program retains its required functionality; that is, it must check the output to ensure that it is still correct.
3. In fact, since modified programs can behave very unpredictably, sandboxing---i.e., containing the process so that it does not consume excess resources nor produce undesirable side-effects---is critical. We provide the `bin/limit` program to restrict the process's access to a number of resources, such as run time, memory, and file handles. However, it in no way completely contains the process. It is very common for modified programs to generate files with arbitrary filenames and even modify important files in the filesystem.
4. PowerGAUGE expects each non-functional property to be represented as a positive floating point number. Since GenProg is designed to maximize values while many non-functional properties are optimized by minimizing them (e.g., runtime), these values are often transformed as `1/(1+x)` before writing them to the file.

Finally, the test command must always have a non-zero exit code. (GenProg looks for the zero exit code to indicate that the optimal program has been found and that it can stop looking.)

> The `benchmarks/swaptions/test-simple.py` script implements a very simple test command. The first time it is run, it stores the binary's output to a file so it can be compared against the output of the modified binaries. It then runs the given binary 5 times and measures the time it takes to run as well as comparing the output against the stored original output. To try it out yourself, run
>
> ```bash
> ./test-simple.py exe /dev/stdout
> ```

With these scripts and assembly files, we are ready to write the configuration file that provides the inputs to GenProg. The GenProg configuration files consist of the same command-line flags and arguments as you can pass on the command line, but in a more convenient (and repeatable) form. For this example, we use the following configuration file:

```
--program multi.txt
--prefix src
--compiler-command ./compile.sh __SOURCE_NAME__ __EXE_NAME__
--test-command ./test-simple.py __EXE_NAME__ __FITNESS_FILE__
--fault-scheme uniform
--fix-scheme uniform
--popsize 512
--max-evals 65536
--seed 0
--rep asm
--sanity no
--single-fitness
--pos-tests 1
--neg-tests 0
--search multiopt
```

GenProg replaces the `__SOURCE_NAME__`, `__EXE_NAME__`, and `__FITNESS_FILE__` variables with appropriate filenames before calling the commands. GenProg supports a number of flags that are not listed here; see the GenProg documentation for descriptsions of the available flags. Note that the flags after `--seed` in the file above are the same for all PowerGAUGE runs.

### Optional Inputs

TODO: Describe collecting coverage information with `asm-coverage.py` and `asm-map.py`

### Running

Run GenProg with

```bash
repair configuration
```

This may take several hours, depending on how many variants GenProg must evaluate (`--max-evals`).

When it is done, GenProg will have created large logfile named `repair.debug.0` listing every modification that GenProg attempted and its measured fitness. The `bin/parse-genprog-log.py` script will process that file and report the best variants evaluated by GenProg.

```bash
../../bin/parse-genprog-log.py \
    --filter best \
    --no-confidence \
    --csv best.csv \
    repair.debug.0
```

> The `--no-confidence` flag ignores confidence intervals while computing the set of best variants. It produces a smaller set of variants and allows the script to run significantly faster. However, when fitness values are uncertain, it may mistakenly ignore interesting variants that happen to have poorer average fitness values.

The CSV file contains the fitness values for each optimized variant along with a set of edits. Some of these edits may be superfluous, while others may cause non-deterministically poor behavior. The `bin/maximize.py` script attempts to find the set of edits that avoid non-deterministic behavior, while `bin/minimize.py` attempts to find the smallest set of edits that achieve the full optimization. Both are based on [DeltaDebugging](https://www.st.cs.uni-saarland.de/dd/).

Run `maximize.py` to filter out non-deterministic behavior (if any). It measures non-deterministic behavior by running the variant several times and checking that the performance is consistent. It uses the DeltaDebugging algorithm to search for a one-maximal subset that avoids non-deterministic behavior. This step is usually relatively quick. Be sure to replace `'a(1, 2) d(3)'` with the set of edits discovered by your search.

```bash
../../bin/maximize.py \
    repair \
    configuration \
    --genome 'a(1,2) d(3) s(4,5)'
```

Consult the `maximize.py` help text for descriptions of the available command-line arguments.

Once this script finishes, it will report a subset of the edits that produce a program with deterministic behavior. You can now run `minimize.py` to eliminate unnecessary edits. It considers an edit to be unnecessary if the program's performance is not affected whether the edit is applied or not. It uses DeltaDebugging to identify a one-minimal subset of edits has the same performance as the complete set of edits. This both helps with understanding how the edits improved the program, since a smaller set of edits is easier to understand, and also reduces the chance that the optimization will negatively impact functionality that was not exercised by the `test-simple.py` script.

Note that to get an accurate measurement of the performance of the program, `minimize.py` runs each variant many times. This, coupled with potentially large numbers of edits to search with DeltaDebugging, means that this step may sometimes take as long or longer than the original GenProg search. Run minimization with the following command,

```bash
../../bin/minimize.py \
    repair \
    configuration \
    --genome 'a(1,2) d(3) a(4,5) d(4)'
    --save-binary minimized.exe
```

Consult the `minimize.py` help text for descriptions of the available command-line arguments.

This will report the minimized genome and store the corresponding binary as `minimized.exe`.

NOTE: The `simplify-genome.py` script automates running `parse-genprog-log.py`, `maximize.py`, and `minimize.py` in sequence on every variant in the set of optimized programs. However, it can produce a large number of extraneous files, which can clutter your directory structure.
